{
  parserClass="nim.parser.NimParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nim"
  psiImplClassSuffix="Impl"
  psiPackage="nim.psi"
  psiImplPackage="nim.psi.impl"

  elementTypeHolderClass="nim.psi.NimTypes"
  elementTypeClass="nim.psi.NimElementType"
  tokenTypeClass="nim.psi.NimTokenType"

  tokens = [
    T_IF='if'
    T_WHEN='when'
    T_WHILE='while'
    T_CASE='case'
//    T_FOR='for'
    //T_VAR='var'
    T_LET='let'
    T_CONST='const'
    T_BLOCK='block'
    T_TRY='try'
    T_EXCEPT='except'
    T_FINALLY='finally'
    T_INCLUDE='include'
    T_MIXIN='mixin'
    T_DISCARD='discard'

    //OP_ASSIGN='='
//    OP_PLUS='+'
//    OP_MINUS='-'
//    OP_MULTIPLY='*'
//    OP_DIVIDE='/'
//    OP_EQ='=='
//    OP_NE='!='
//    OP_LT='<'
//    OP_LE='<='
//    OP_GT='>'
//    OP_GE='>='
  ]
}

module ::= import_section ? ( var_init_block | let_init_block | const_init_block | proc | nonempty_block | TEMPLATE | COMMENT ) *

import_section ::= T_IMPORT ident_list

var_init_block ::= T_VAR var_init+
var_init ::= ident_init

let_init_block ::= T_LET let_init+
let_init ::= ident_init

const_init_block ::= T_CONST const_init+
const_init ::= ident_init

ident_init ::= ident_list ( ( ( COLON type )? OP_ASSIGN expr ) | COLON type )
ident_list ::= IDENTIFIER ( COMMA IDENTIFIER ) *

proc ::= T_PROC ( ( IDENTIFIER '*' ? ) | OPERATOR_IDENTIFIER ) params_list ( COLON type ) ? OP_ASSIGN ( var_init_block | let_init_block | nonempty_block | COMMENT ) * return_ ?
params_list ::= OPEN_BRACKET ( ident_list COLON type ( COMMA ident_list COLON type ) * )? CLOSE_BRACKET
return_ ::= T_RETURN expr ?

stmt ::= ident_or_field OP_ASSIGN expr
expr ::= operator_expr | bool_expr | expr_
operator_expr ::= expr_ operator expr_ ( operator expr_ ) *
expr_ ::= invokation | NIL | ident_expr | literal_expr | paren_expr | bool_literal
invokation ::= ident_or_field OPEN_BRACKET expr ? ( COMMA expr ) * CLOSE_BRACKET
paren_expr ::= OPEN_BRACKET expr CLOSE_BRACKET
ident_expr ::= ident_or_field
literal_expr ::= literal
literal ::= STRING | CHAR | NUMBER
operator ::= OP_PLUS | OP_MINUS | OP_MULTIPLY | OP_DIVIDE | OP_MOD | OP_AND | OP_XOR | OP_OR | OP_AND_FULL | OP_XOR_FULL | OP_OR_FULL

type ::= 'string' | 'bool' | 'int' | IDENTIFIER

if_block ::= T_IF bool_expr COLON block ( elif_block ) * else_block ?
elif_block ::= T_ELIF bool_expr COLON block
else_block ::= T_ELSE COLON block
bool_expr ::= ( ( operator_expr | expr_ ) boolean_operator ( expr_ | operator_expr ) ( boolean_operator expr_ ) * ) | bool_literal
boolean_operator ::= OP_EQ | OP_NE | OP_LT | OP_LE | OP_GT | OP_GE | OP_LOGICAL_OR | OP_LOGICAL_AND

for_block ::= T_FOR ident_or_field T_IN range COLON
range ::= int_range | char_range
int_range ::= NUMBER T_RANGE NUMBER
char_range ::= CHAR T_RANGE CHAR

while_block ::= T_WHILE bool_expr COLON
bool_literal ::= T_TRUE | T_FALSE

case_block ::= T_CASE ident_or_field of_block + else_block ?
of_block ::= T_OF of_value_list COLON
of_value_list ::= of_value ( COMMA of_value ) *
of_value ::= ident_or_field | range | literal

nonempty_block ::= block_ +
block ::= block_ *
block_ ::= if_block | for_block | while_block | case_block | block_expr | break_expr | stmt | invokation | discard_expr | echo
block_expr ::= T_BLOCK IDENTIFIER COLON
break_expr ::= T_BREAK IDENTIFIER ?
discard_expr ::= T_DISCARD expr

echo ::= KEYWORD expr_list
expr_list ::= expr ( COMMA expr ) *
ident_or_field ::= IDENTIFIER ( T_DOT IDENTIFIER ) ?